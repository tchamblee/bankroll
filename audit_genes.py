import os
import sys
import numpy as np
import pandas as pd
import tempfile
import shutil
from genome.genes import (
    ZScoreGene, SoftZScoreGene, RelationalGene, SqueezeGene, CorrelationGene, FluxGene,
    EfficiencyGene, DivergenceGene, EventGene, CrossGene, PersistenceGene,
    ExtremaGene, ConsecutiveGene, DeltaGene, SeasonalityGene, MeanReversionGene, TimeGene,
    HysteresisGene, ProximityGene, ValidityGene
)
from backtest.feature_computation import ensure_feature_context, precompute_base_features
from genome.strategy import Strategy

def create_mock_data():
    """Generates a small random dataframe for testing."""
    n = 100
    df = pd.DataFrame({
        'close': np.random.randn(n).cumsum() + 100,
        'high': np.random.randn(n).cumsum() + 105,
        'low': np.random.randn(n).cumsum() + 95,
        'volume': np.random.randint(100, 1000, n),
        'time_start': pd.date_range(start='2024-01-01', periods=n, freq='5min'),
        'feature_a': np.random.randn(n),
        'feature_b': np.random.randn(n),
        'regime_x': np.random.randn(n)
    })
    # Ensure no NaNs
    df = df.fillna(0)
    return df

def audit_genes():
    print("üß¨ GENE INTEGRITY AUDIT")
    print("=======================")

    # 1. Instantiate one of every gene
    print("[1/3] Instantiating Genes...")
    genes = [
        ZScoreGene('feature_a', '>', 1.0, 10),
        SoftZScoreGene('feature_a', '>', 1.0, 20, 1.0),
        RelationalGene('feature_a', '>', 'feature_b'),
        SqueezeGene('feature_a', 'feature_b', 0.8),
        CorrelationGene('feature_a', 'feature_b', '>', 0.5, 20),
        FluxGene('feature_a', '>', 0.1, 5),
        EfficiencyGene('feature_a', '>', 0.5, 10),
        DivergenceGene('feature_a', 'feature_b', 10),
        EventGene('feature_a', '>', 1.0, 10),
        CrossGene('feature_a', 'above', 'feature_b'),
        PersistenceGene('feature_a', '>', 0.0, 5),
        ExtremaGene('feature_a', 'max', 10),
        ConsecutiveGene('up', '>', 2),
        DeltaGene('feature_a', '>', 0.1, 5),
        MeanReversionGene('feature_a', 'regime_x', 2.0, 0.5, 'long', 10),
        TimeGene('hour', '>', 12),
        HysteresisGene('feature_a', '>', 10),
        ProximityGene('feature_a', 'max', 0.1, 10),
        ValidityGene('feature_a', '>', 0.0, 10, 0.8)
    ]
    
    # Wrap in a dummy strategy
    strat = Strategy("Audit_Strat", genes, [], 1, 0.01, 0.01)
    population = [strat]
    
    # 2. Test Feature Computation Pipeline
    print("[2/3] Testing JIT Feature Pipeline...")
    df = create_mock_data()
    temp_dir = tempfile.mkdtemp()
    existing_keys = set()
    
    try:
        # A. Precompute Base
        precompute_base_features(df, temp_dir, existing_keys)
        
        # Verify Base Features exist
        base_checks = ['close', 'feature_a', 'consecutive_up']
        for k in base_checks:
            if k not in existing_keys:
                print(f"  ‚ùå FAILED: Base feature '{k}' was not generated by precompute_base_features!")
                return False
        
        # B. Ensure Context (Dependency Parsing)
        ensure_feature_context(population, temp_dir, existing_keys)
        
        # Verify Derived Features exist
        derived_checks = [
            'zscore_feature_a_10',          # ZScore
            'zscore_feature_a_20',          # SoftZScore (Unique)
            'corr_feature_a_feature_b_20',  # Correlation
            'flux_feature_a_5',             # Flux
            'eff_feature_a_10',             # Efficiency
            'delta_feature_a_5',            # Delta
            'slope_feature_a_10',           # Divergence (uses slope)
        ]
        
        for k in derived_checks:
            if k not in existing_keys:
                print(f"  ‚ùå FAILED: Derived feature '{k}' was not generated! (Dependency parsing or JIT worker failed)")
                return False

    except Exception as e:
        print(f"  ‚ùå CRASH: Feature computation crashed: {e}")
        import traceback
        traceback.print_exc()
        return False
    finally:
        shutil.rmtree(temp_dir)
        
    print("  ‚úÖ Pipeline computed all required keys.")
    
    # 3. Test Evaluation (Runtime)
    # We need a context dictionary with actual numpy arrays
    print("[3/3] Testing Gene Evaluation...")
    
    # Manually populate context with mock data matching the keys
    n = 100
    context = {
        '__len__': n,
        'feature_a': np.random.randn(n),
        'feature_b': np.random.randn(n),
        'regime_x': np.random.randn(n),
        'close': np.random.randn(n),
        # Pre-calculated derived keys that genes expect
        'zscore_feature_a_10': np.random.randn(n),
        'zscore_feature_a_20': np.random.randn(n),
        'corr_feature_a_feature_b_20': np.random.randn(n),
        'flux_feature_a_5': np.random.randn(n),
        'eff_feature_a_10': np.random.randn(n),
        'delta_feature_a_5': np.random.randn(n),
        'slope_feature_a_10': np.random.randn(n),
        'slope_feature_b_10': np.random.randn(n),
        'consecutive_up': np.random.randint(0, 5, n),
        'consecutive_down': np.random.randint(0, 5, n),
        'time_hour': np.random.randint(0, 24, n)
    }
    
    for gene in genes:
        try:
            res = gene.evaluate(context)
            if not isinstance(res, np.ndarray):
                print(f"  ‚ùå FAILED: {gene.type} returned {type(res)}, expected np.ndarray")
                return False
            if len(res) != n:
                 print(f"  ‚ùå FAILED: {gene.type} returned length {len(res)}, expected {n}")
                 return False
            # Check for all False (could be valid, but suspicious for mock data)
            # Actually, random data might result in all False for strict genes. 
            # We just want no crash.
        except Exception as e:
            print(f"  ‚ùå CRASH: {gene.type}.evaluate() failed: {e}")
            return False
            
    print("  ‚úÖ All genes evaluated successfully.")
    print("\nüéâ AUDIT PASSED: Genome Integrity Verified.")
    return True

if __name__ == "__main__":
    success = audit_genes()
    sys.exit(0 if success else 1)
